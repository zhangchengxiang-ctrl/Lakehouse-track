user root;
worker_processes auto;

error_log /var/log/nginx/error.log warn;
pid /var/run/nginx.pid;

events {
    worker_connections 8192;
    multi_accept on;           # 每次 epoll_wait 返回后尽可能 accept 所有就绪连接
    accept_mutex off;          # 高并发下关闭互斥锁，所有 worker 同时 accept
}

http {
    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    map $http_x_forwarded_for  $clientRealIp {
        ""    $remote_addr;
        ~^(?P<firstAddr>[0-9\.]+),?.*$    $firstAddr;
    }

    log_format main '$clientRealIp - $remote_user [$time_local] "$request" $status $body_bytes_sent "$http_referer" "$http_user_agent" "$http_x_forwarded_for" "$request_body" "$upstream_addr"';
    log_format log_extractor '"$proxy_add_x_forwarded_for" ++_ "$msec" ++_ "$request_method" ++_ "$arg_gzip" ++_ "$arg_data" ++_ "$arg_data_list" ++_ "$request_body" ++_ "$http_user_agent" ++_ "$arg_project" ++_ "$http_cookie" ++_ "$arg_token" ++_ "$arg_ext"';

    # 默认 access_log 关闭（埋点写在 location 级别，避免同文件参数冲突）
    access_log off;
    
    sendfile on;
    tcp_nopush on;             # 配合 sendfile，合并小包减少网络调用
    tcp_nodelay on;            # 关闭 Nagle 算法，小包立即发送
    keepalive_timeout 30;      # 埋点短请求，30s 足够（原 65s 浪费连接资源）
    client_body_timeout 10;    # POST body 读取超时
    send_timeout 10;           # 响应发送超时
    types_hash_max_size 2048;
    server_tokens off;

    gzip on;
    gzip_types text/plain text/css application/json application/javascript application/octet-stream;

    # 内部 sink：仅用于 proxy_pass 强制 Nginx 读取 POST body
    server {
        listen 127.0.0.1:81;
        access_log off;
        location / { return 204; }
    }

    server {
        listen 80;
        server_name localhost;

        # 全局 POST body 缓冲（确保 $request_body 可用）
        client_body_buffer_size 2m;
        client_max_body_size 2m;
        client_body_in_single_buffer on;

        if ($time_iso8601 ~ "^(\d{4})-(\d{2})-(\d{2})T(\d{2})") {
            set $year $1;
            set $month $2;
            set $day $3;
            set $hour $4;
        }

        # 健康检查端点
        location /health {
            access_log off;
            return 200 "healthy\n";
            add_header Content-Type text/plain;
        }

        location /sa.gif {
            add_header 'Access-Control-Allow-Origin' '*';
            if ($request_method = 'OPTIONS') {
                access_log off;
                return 204;
            }
            add_header Cache-Control 'no-cache, no-store, must-revalidate';
            add_header Pragma 'no-cache';
            add_header Expires 'Mon, 28 Sep 1970 05:00:00 GMT';
            # buffer=256k: 日志先写内存缓冲区，满 256KB 或超 1s 才 flush 到磁盘
            # 消除每条请求同步 write() 的 I/O 瓶颈，吞吐提升显著
            # 注：不能用 gzip，因为 Vector file source 只能读取纯文本
            access_log /var/log/nginx/access.log log_extractor buffer=256k flush=1s;
            proxy_pass http://127.0.0.1:81;
            proxy_set_header Host $host;
        }

        location = /sa {
            add_header Cache-Control 'no-cache, no-store, must-revalidate';
            access_log /var/log/nginx/access.log log_extractor buffer=256k flush=1s;
            proxy_pass http://127.0.0.1:81;
            proxy_set_header Host $host;
        }

        # SDK 配置相关 (迁移自 StellarTrace)
        location ~ ^/config/(iOS|Android)\.conf$ {
            access_log off;
            alias /etc/nginx/sdk_debug;
            if ($arg_app_id = "") {
                rewrite /config/(iOS|Android) /config/$1 last;
            }
            if (!-d "$request_filename/sdk_config") {
                rewrite /config/(iOS|Android) /config/$1 last;
            }
            set $sdk_config_project "default";
            if ($arg_project != "") {
                set $sdk_config_project $arg_project;
            }
            set $sdk_config_path "sdk_config/$sdk_config_project/$1/$arg_app_id";
            if ( !-d "$request_filename/$sdk_config_path" ) {
                return 205;
            }
            if ( -f "$request_filename/$sdk_config_path/$1_${arg_v}_nv$arg_nv" ) {
                return 304;
            }
            rewrite /config/(iOS|Android) /$sdk_config_path/$1 last;
        }

        location ~ ^/sdk_config {
            access_log off;
            default_type application/json;
            root /etc/nginx/sdk_debug;
        }

        location = /config/ {
            access_log off;
            return 200;
        }

        location /config {
            access_log off;
            alias /etc/nginx/sdk_debug;
            default_type application/json;
            if ( -f "${request_filename}_${arg_v}") {
                return 304;
            }
        }

        location = /robots.txt {
            return 200 "User-agent: *\nDisallow: /";
            access_log off;
        }
    }
}
