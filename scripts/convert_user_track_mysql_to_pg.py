#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
将 StellarTrace 的 init_mysql.sql 转换为 PostgreSQL 可执行脚本。
输出文件：postgres/init/04-init-user-track.sql
"""

from pathlib import Path
import re


PROJECT_DIR = Path(__file__).resolve().parents[1]
MYSQL_DUMP = PROJECT_DIR.parent / "StellarTrace" / "deployment" / "db_init" / "init_mysql.sql"
OUTPUT_SQL = PROJECT_DIR / "postgres" / "init" / "04-init-user-track.sql"


DDL = """-- user_track 元数据初始化 (PostgreSQL)
CREATE SCHEMA IF NOT EXISTS user_track;

DROP TABLE IF EXISTS user_track.event_property;
DROP TABLE IF EXISTS user_track.event_define;
DROP TABLE IF EXISTS user_track.property_define;
DROP TABLE IF EXISTS user_track.project;

CREATE TABLE user_track.project (
  id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name VARCHAR(100) NOT NULL,
  cname VARCHAR(255),
  super_token VARCHAR(255),
  normal_token VARCHAR(255),
  is_auto_create SMALLINT DEFAULT 1,
  status INTEGER NOT NULL,
  delete_time TIMESTAMP,
  create_time TIMESTAMP
);

CREATE UNIQUE INDEX IF NOT EXISTS idx_project_name
  ON user_track.project(name);

CREATE TABLE user_track.event_define (
  id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  project_id INTEGER NOT NULL DEFAULT 1,
  name VARCHAR(100) NOT NULL,
  cname VARCHAR(100),
  visible SMALLINT DEFAULT 1,
  virtual SMALLINT DEFAULT 0,
  bucket_id INTEGER,
  is_visualized SMALLINT DEFAULT 0,
  virtual_define TEXT,
  accepted SMALLINT DEFAULT 1,
  total_count BIGINT DEFAULT 0,
  track_info TEXT,
  comment TEXT,
  user_id INTEGER,
  update_time TIMESTAMP(6) DEFAULT CURRENT_TIMESTAMP,
  create_time TIMESTAMP(6) DEFAULT CURRENT_TIMESTAMP
);

CREATE UNIQUE INDEX IF NOT EXISTS idx_event_define_project_name
  ON user_track.event_define(project_id, name);

CREATE TABLE user_track.property_define (
  id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  project_id INTEGER NOT NULL DEFAULT 1,
  name VARCHAR(100) NOT NULL,
  cname VARCHAR(100),
  unit VARCHAR(16),
  data_type INTEGER NOT NULL,
  comment TEXT,
  is_common SMALLINT DEFAULT 0,
  is_dimension SMALLINT,
  is_measure SMALLINT,
  is_in_use SMALLINT DEFAULT 1,
  is_load SMALLINT DEFAULT 1,
  has_dict SMALLINT DEFAULT 0,
  default_value VARCHAR(1024),
  type_flexible INTEGER DEFAULT 1,
  track_info TEXT,
  view_column_name VARCHAR(128),
  update_time TIMESTAMP(6) DEFAULT CURRENT_TIMESTAMP,
  create_time TIMESTAMP(6) DEFAULT CURRENT_TIMESTAMP
);

CREATE UNIQUE INDEX IF NOT EXISTS idx_property_define_project_name
  ON user_track.property_define(name, project_id);

CREATE TABLE user_track.event_property (
  id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  event_id INTEGER NOT NULL,
  property_id INTEGER NOT NULL,
  update_time TIMESTAMP(6) DEFAULT CURRENT_TIMESTAMP
);

CREATE UNIQUE INDEX IF NOT EXISTS idx_event_property_unique
  ON user_track.event_property(event_id, property_id);

CREATE TABLE user_track.user_id_mapping (
  project_name VARCHAR(100) NOT NULL,
  distinct_id VARCHAR(256) NOT NULL,
  map_id VARCHAR(256) NOT NULL,
  map_type VARCHAR(100) NOT NULL,
  login_id VARCHAR(256),
  load_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (project_name, distinct_id)
);
"""


def _normalize_insert(stmt: str) -> str:
    stmt = stmt.replace("`", "")
    stmt = stmt.replace("user_track.", "user_track.")
    return stmt


# 依赖顺序：project 无依赖，event_define/property_define 依赖 project，event_property 依赖前两者
INSERT_ORDER = ("project", "event_define", "property_define", "event_property")

# 有 IDENTITY 列的表，插入后需重置序列
TABLES_WITH_IDENTITY = ("project", "event_define", "property_define", "event_property")


def _extract_inserts(sql: str) -> dict[str, str]:
    pattern = r"INSERT INTO `user_track`\.`([^`]+)`.*?;"
    inserts = {}
    for match in re.finditer(pattern, sql, re.S):
        table = match.group(1)
        inserts[table] = _normalize_insert(match.group(0))
    return inserts


def _seq_reset_stmt(table: str) -> str:
    return f"SELECT setval(pg_get_serial_sequence('user_track.{table}', 'id'), COALESCE((SELECT MAX(id) FROM user_track.{table}), 1));"


def main() -> None:
    if not MYSQL_DUMP.exists():
        raise SystemExit(f"未找到 MySQL dump: {MYSQL_DUMP}")

    raw = MYSQL_DUMP.read_text(encoding="utf-8", errors="ignore")

    inserts = _extract_inserts(raw)

    lines = ["-- 初始化数据 (来自 init_mysql.sql)", "-- 顺序：project -> event_define -> property_define -> event_property (满足外键依赖)"]
    for table in INSERT_ORDER:
        if table in inserts:
            lines.append(inserts[table])
            if table in TABLES_WITH_IDENTITY:
                lines.append(_seq_reset_stmt(table))

    OUTPUT_SQL.write_text(
        DDL + "\n\n" + "\n".join(lines) + "\n",
        encoding="utf-8",
    )
    print(f"已生成: {OUTPUT_SQL}")


if __name__ == "__main__":
    main()
